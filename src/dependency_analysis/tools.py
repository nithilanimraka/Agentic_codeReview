import os
import json
import requests
import logging
from urllib.parse import urlparse
from langchain.tools import tool
from neo4j import GraphDatabase
from typing import Optional, Tuple, List, Dict
from dotenv import load_dotenv

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_github_owner_repo(repo_url: str) -> Optional[Tuple[str, str]]:
    """Parses GitHub URL to extract owner and repo name."""
    try:
        parsed_url = urlparse(repo_url)
        if parsed_url.netloc.lower() != 'github.com':
            return None
        path_parts = [p for p in parsed_url.path.strip('/').split('/') if p]
        return (path_parts[0], path_parts[1].replace('.git', '')) if len(path_parts) >= 2 else None
    except Exception as e:
        logger.error(f"Error parsing GitHub URL: {e}")
        return None

class Neo4jDriver:
    _instance = None

    def __new__(cls, uri: str, user: str, password: str):
        if cls._instance is None:
            cls._instance = GraphDatabase.driver(uri, auth=(user, password))
        return cls._instance

@tool
def retrieve_dependency_graphs(repository_id: str, neo4j_uri: str, neo4j_user: str, neo4j_pass: str) -> str:
    """Retrieves dependency graphs from Neo4j."""
    try:
        driver = Neo4jDriver(neo4j_uri, neo4j_user, neo4j_pass)
        with driver.session() as session:
            result = session.run("""
                MATCH (n)-[r]->(m)
                WHERE n.repository_id = $repo_id OR m.repository_id = $repo_id
                RETURN n, r, m
            """, repo_id=repository_id)

            graph_data = {"nodes": [], "relationships": []}
            nodes_seen = set()
            for record in result:
                n = record["n"]
                m = record["m"]
                r = record["r"]
                
                for node in [n, m]:
                    if node.id not in nodes_seen:
                        graph_data["nodes"].append({
                            "id": node.id,
                            "labels": list(node.labels),
                            "properties": dict(node)
                        })
                        nodes_seen.add(node.id)
                
                graph_data["relationships"].append({
                    "source": n.id,
                    "target": m.id,
                    "type": r.type,
                    "properties": dict(r)
                })

            return json.dumps(graph_data)
    except Exception as e:
        logger.error(f"Neo4j query error: {e}")
        raise

@tool
def store_dependencies(repository_id: str, dependencies: List[Dict], neo4j_uri: str, neo4j_user: str, neo4j_pass: str) -> str:
    """Stores analyzed dependencies in Neo4j database."""
    try:
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_pass))
        with driver.session() as session:
            # Create repository node with additional metadata
            session.run("""
                MERGE (r:Repository {repository_id: $repo_id})
                SET r.last_updated = datetime(),
                    r.name = $repo_id,
                    r.type = 'github'
            """, repo_id=repository_id)

            # Process dependencies with better logging
            for dep in dependencies:
                logger.info(f"Storing dependency: {dep}")
                session.run("""
                    MATCH (repo:Repository {repository_id: $repo_id})
                    MERGE (src:File {name: $source, repository_id: $repo_id})
                    MERGE (tgt:File {name: $target, repository_id: $repo_id})
                    SET src.type = $source_type,
                        tgt.type = $target_type,
                        src.last_updated = datetime(),
                        tgt.last_updated = datetime()
                    MERGE (src)-[r:DEPENDS_ON {type: $dep_type}]->(tgt)
                    SET r.last_updated = datetime(),
                        r.description = $dep_description
                """, 
                repo_id=repository_id,
                source=dep.get('source'),
                target=dep.get('target'),
                source_type=dep.get('source_type', 'File'),
                target_type=dep.get('target_type', 'File'),
                dep_type=dep.get('type', 'depends_on'),
                dep_description=dep.get('description', 'autogenerated dependency'))
            
            # Verify creation
            result = session.run("""
                MATCH (r:Repository {repository_id: $repo_id})-[:CONTAINS]->(f:File)
                RETURN count(f) as file_count
            """, repo_id=repository_id)
            count = result.single()["file_count"]
            return f"Stored {count} files with dependencies"
    except Exception as e:
        logger.error(f"Neo4j storage failed: {e}")
        raise

@tool
def get_file_content(repo_url: str, commit_sha: str, file_path: str) -> str:
    """Retrieves full content of a file from GitHub repository."""
    try:
        owner, repo = get_github_owner_repo(repo_url)
        if not owner or not repo:
            raise ValueError("Invalid GitHub URL")

        url = f"https://api.github.com/repos/{owner}/{repo}/contents/{file_path}?ref={commit_sha}"
        headers = {
            'Authorization': f'Bearer {os.getenv("GITHUB_TOKEN")}',
            'Accept': 'application/vnd.github.v3.raw',
            'X-GitHub-Api-Version': '2022-11-28'
        }

        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        return response.text
        
    except Exception as e:
        logger.error(f"Failed to fetch file content: {str(e)}")
        return f"File content unavailable: {str(e)}"

def get_changed_files_from_pr(owner: str, repo: str, pr_number: int) -> list[str]:
    """Fetches the list of changed files for a given PR using GitHub API."""
    logger.info(f"Fetching changed files for PR #{pr_number} in {owner}/{repo}")
    github_token = os.getenv("GITHUB_TOKEN")
    if not github_token:
        raise ValueError("GITHUB_TOKEN not configured")

    url = f"https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/files"
    headers = {
        'Authorization': f'Bearer {github_token}',
        'Accept': 'application/vnd.github.v3+json',
        'X-GitHub-Api-Version': '2022-11-28'
    }

    changed_files = []
    page = 1
    while True:
        try:
            response = requests.get(url, headers=headers, params={'page': page, 'per_page': 100}, timeout=20)
            response.raise_for_status()
            files = response.json()
            if not files:
                break
            changed_files.extend([f['filename'] for f in files if f.get('filename')])
            if 'next' not in response.links:
                break
            page += 1
        except requests.exceptions.RequestException as e:
            logger.error(f"GitHub API error: {str(e)}")
            raise ValueError(f"Failed to fetch changed files: {str(e)}")

    logger.info(f"Found {len(changed_files)} changed files")
    return changed_files


def close_neo4j_driver():
    """Closes the Neo4j driver."""
    if Neo4jDriver._instance:
        Neo4jDriver._instance.close()
        Neo4jDriver._instance = None


def initialize_neo4j_schema():
    """Creates database constraints and indexes on startup"""
    try:
        driver = GraphDatabase.driver(
            os.getenv("NEO4J_URI"),
            auth=(os.getenv("NEO4J_USERNAME"), os.getenv("NEO4J_PASSWORD"))
        )
        
        with driver.session() as session:
            # Node constraints
            session.run("""
                CREATE CONSTRAINT IF NOT EXISTS 
                FOR (r:Repository) REQUIRE r.repository_id IS UNIQUE
            """)
            
            session.run("""
                CREATE CONSTRAINT IF NOT EXISTS 
                FOR (f:File) REQUIRE (f.repository_id, f.name) IS UNIQUE
            """)

            # Relationship property indexes (corrected)
            session.run("""
                CREATE INDEX IF NOT EXISTS 
                FOR ()-[r:CONTAINS]-() 
                ON r.created_at
            """)
            
            session.run("""
                CREATE INDEX IF NOT EXISTS 
                FOR ()-[r:DEPENDS_ON]-() 
                ON r.type
            """)
            
        logger.info("Neo4j schema initialized successfully")
        
    except Exception as e:
        logger.error(f"Schema initialization failed: {str(e)}")
        raise
    finally:
        driver.close()